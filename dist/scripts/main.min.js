/*!
 *
 *  Web Starter Kit
 *  Copyright 2015 Google Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License
 *
 */
(function () {
  'use strict';

  // Check to make sure service workers are supported in the current browser,
  // and that the current page is accessed from a secure origin. Using a
  // service worker from an insecure origin will trigger JS console errors. See
  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features
  if ('serviceWorker' in navigator &&
      (window.location.protocol === 'https:' ||
       window.location.hostname === 'localhost' ||
       window.location.hostname.indexOf('127.') === 0)) {
    navigator.serviceWorker.register('/service-worker.js', {
      scope: './'
    }).then(function(registration) {
      // Check to see if there's an updated version of service-worker.js with
      // new files to cache:
      // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-registration-update-method
      if (typeof registration.update === 'function') {
        registration.update();
      }

      // updatefound is fired if service-worker.js changes.
      registration.onupdatefound = function () {
        // updatefound is also fired the very first time the SW is installed,
        // and there's no need to prompt for a reload at that point.
        // So check here to see if the page is already controlled,
        // i.e. whether there's an existing service worker.
        if (navigator.serviceWorker.controller) {
          // The updatefound event implies that registration.installing is set:
          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event
          var installingWorker = registration.installing;

          installingWorker.onstatechange = function () {
            switch (installingWorker.state) {
              case 'installed':
                // At this point, the old content will have been purged and the
                // fresh content will have been added to the cache.
                // It's the perfect time to display a "New content is
                // available; please refresh." message in the page's interface.
                break;

              case 'redundant':
                throw new Error('The installing ' +
                                'service worker became redundant.');
            }
          };
        }
      };
    }).catch(function (e) {
      console.error('Error during service worker registration:', e);
    });
  }

  // Your custom JavaScript goes here
})();

/**
 * Array of images used in the game
 */
var GAME;
(function (GAME) {
    "use strict";
    var Assets;
    (function (Assets) {
        var Images;
        (function (Images) {
            Images.art = [
                "images/gameart/asteroid_large_animated.png",
                "images/gameart/asteroid_medium_animated.png",
                "images/gameart/asteroid_small_animated.png",
                "images/gameart/debris2_blue.png",
                "images/gameart/double_ship.png",
                "images/gameart/explosion.hasgraphics.png",
                "images/gameart/explosion_alpha.png",
                "images/gameart/nebula_blue.f2014.png",
                "images/gameart/shot2.png",
                "images/gameart/splash.png"
            ];
        })(Images = Assets.Images || (Assets.Images = {}));
    })(Assets = GAME.Assets || (GAME.Assets = {}));
})(GAME || (GAME = {}));
//# sourceMappingURL=assets.js.map
/**
 * A simple 2 dimensional vector class
 */
var GAME;
(function (GAME) {
    "use strict";
    var Vector2d = (function () {
        function Vector2d(x, y) {
            this._x = x;
            this._y = y;
        }
        /**
         * Separate the x and y values of an angle
         * @param angle
         * @returns {GAME.Vector2d}
         */
        Vector2d.angleToVector2d = function (angle) {
            return new Vector2d(Math.cos(angle), Math.sin(angle));
        };
        /**
         * Calculate the distance between 2 points
         * @param p
         * @param q
         * @returns {number}
         */
        Vector2d.distance = function (p, q) {
            return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2));
        };
        Vector2d.prototype.set = function (x, y) {
            this._x = x;
            this._y = y;
        };
        Object.defineProperty(Vector2d.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                this._x = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2d.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                this._y = y;
            },
            enumerable: true,
            configurable: true
        });
        return Vector2d;
    })();
    GAME.Vector2d = Vector2d;
})(GAME || (GAME = {}));
//# sourceMappingURL=vector2d.js.map
/**
 * This is a collection of all the sprite configurations used in the game
 */
/// <reference path='includes.ts'/>
var GAME;
(function (GAME) {
    "use strict";
    /**
     * AnimationInfo class is used to describe animation speed and frame count
     */
    var AnimationInfo = (function () {
        /**
         * AnimationInfo class constructor
         * @param animationSpeed
         * @param numberOfFrames
         */
        function AnimationInfo(animationSpeed, numberOfFrames) {
            this.animationSpeed = animationSpeed;
            this.numberOfFrames = numberOfFrames;
        }
        return AnimationInfo;
    })();
    GAME.AnimationInfo = AnimationInfo;
    /**
     * SpriteInfo class is used to describe source, dimensions, and radius
     * NOTE: Radius is used for simulation objects during collision detection
     */
    var SpriteInfo = (function () {
        /**
         * SpriteInfo class constructor
         * @param url
         * @param width
         * @param height
         * @param radius
         */
        function SpriteInfo(url, width, height, radius) {
            if (radius === void 0) { radius = 0; }
            this.url = url;
            this.width = width;
            this.height = height;
            this.halfWidth = this.width / 2;
            this.halfHeight = this.height / 2;
            this.radius = radius;
        }
        return SpriteInfo;
    })();
    GAME.SpriteInfo = SpriteInfo;
    /**
     * SpriteConfigs class contains the predefined attributes for the various sprites
     * in the game. SpriteMaker uses these to create the appropriate sprite.
     */
    var SpriteConfigs = (function () {
        function SpriteConfigs() {
        }
        // explosion effect configurations
        SpriteConfigs.explosionAnimationInfo = new AnimationInfo(1, 64);
        SpriteConfigs.explosionSpriteInfo = new SpriteInfo("images/gameart/explosion.hasgraphics.png", 100, 100);
        // shield damage effect configurations
        SpriteConfigs.shieldDamageAnimationInfo = new AnimationInfo(2, 24);
        SpriteConfigs.shieldDamageSpriteInfo = new SpriteInfo("images/gameart/explosion_alpha.png", 128, 128);
        // asteroid configurations for small, medium, and large sizes
        SpriteConfigs.asteroidAnimationInfo = new AnimationInfo(3, 24);
        SpriteConfigs.asteroidLargeSpriteInfo = new SpriteInfo("images/gameart/asteroid_large_animated.png", 96, 96, 26);
        SpriteConfigs.asteroidMediumSpriteInfo = new SpriteInfo("images/gameart/asteroid_medium_animated.png", 72, 72, 17);
        SpriteConfigs.asteroidSmallSpriteInfo = new SpriteInfo("images/gameart/asteroid_small_animated.png", 48, 48, 13);
        // missile configuration
        SpriteConfigs.missileSpriteInfo = new SpriteInfo("images/gameart/shot2.png", 10, 10, 9);
        // ship configuration
        SpriteConfigs.shipSpriteInfo = new SpriteInfo("images/gameart/double_ship.png", 90, 90, 30);
        // background image configuration
        SpriteConfigs.backgroundSpriteInfo = new SpriteInfo("images/gameart/nebula_blue.f2014.png", 800, 600);
        // debris field configuration
        SpriteConfigs.debrisFieldSpriteInfo = new SpriteInfo("images/gameart/debris2_blue.png", 640, 480);
        // splash screen configuration
        SpriteConfigs.splashSpriteInfo = new SpriteInfo("images/gameart/splash.png", 400, 300);
        return SpriteConfigs;
    })();
    GAME.SpriteConfigs = SpriteConfigs;
})(GAME || (GAME = {}));
//# sourceMappingURL=sprite-configs.js.map
/**
 * This is a collection of all the sprite types used in the game.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path='includes.ts'/>
var GAME;
(function (GAME) {
    "use strict";
    /**
     * The base sprite class that all Sprites derive from
     */
    var Sprite = (function () {
        /**
         * Sprite class constructor
         * @param spriteInfo
         * @param x
         * @param y
         * @param visible
         */
        function Sprite(spriteInfo, x, y, visible) {
            if (visible === void 0) { visible = true; }
            /**
             * This function must be overridden in a subclass if used
             * @param context2d
             */
            this.render = function (context2d) {
                throw {
                    error: "Sprite render() not implemented",
                    message: "Implement render function in subclass"
                };
            };
            /**
             * This function must be overridden in a subclass if used
             */
            this.update = function () {
                throw {
                    error: "Sprite update() not implemented",
                    message: "Implement update function in subclass"
                };
            };
            this.spriteInfo = spriteInfo;
            this.position = new GAME.Vector2d(x, y);
            this.visible = visible;
            this.active = true;
        }
        return Sprite;
    })();
    GAME.Sprite = Sprite;
    /**
     * Sprite class for animated effects
     */
    var Effect = (function (_super) {
        __extends(Effect, _super);
        /**
         * Effect class constructor
         * @param spriteInfo
         * @param animationInfo
         * @param x
         * @param y
         */
        function Effect(spriteInfo, animationInfo, x, y) {
            var _this = this;
            _super.call(this, spriteInfo, x, y, true);
            /**
             * Effect render function
             * @param context2d
             */
            this.render = function (context2d) {
                var image = GAME.Resources.instance.getImage(_this.spriteInfo.url), xOffset, yOffset;
                if (!_this.visible) {
                    return;
                }
                if (_this.frame === _this.animationInfo.numberOfFrames) {
                    _this.finished = true;
                    _this.visible = false;
                    return;
                }
                _this.tickCount += 1;
                if (_this.tickCount % _this.animationInfo.animationSpeed === 0) {
                    _this.frame += 1;
                }
                xOffset = (_this.frame % 9) * _this.spriteInfo.width;
                yOffset = Math.floor(_this.frame / 9) * _this.spriteInfo.height;
                context2d.save();
                context2d.translate(_this.position.x, _this.position.y);
                if (image) {
                    context2d.drawImage(image, xOffset, yOffset, _this.spriteInfo.width, _this.spriteInfo.height, -_this.spriteInfo.halfWidth, -_this.spriteInfo.halfHeight, _this.spriteInfo.width, _this.spriteInfo.height);
                }
                context2d.restore();
            };
            this.animationInfo = animationInfo;
            this.frame = 0;
            this.tickCount = -1;
            this.finished = false;
        }
        return Effect;
    })(Sprite);
    GAME.Effect = Effect;
    /**
     * Background class for space nebula
     */
    var Background = (function (_super) {
        __extends(Background, _super);
        /**
         * Background class constructor
         * @param spriteInfo
         * @param x
         * @param y
         */
        function Background(spriteInfo, x, y) {
            var _this = this;
            _super.call(this, spriteInfo, x, y);
            /**
             * Background render function
             * @param context2d
             */
            this.render = function (context2d) {
                context2d.save();
                var image = GAME.Resources.instance.getImage(_this.spriteInfo.url);
                if (image) {
                    context2d.drawImage(image, 0, 0, _this.spriteInfo.width, _this.spriteInfo.height, 0, 0, GAME.SCREEN_WIDTH, GAME.SCREEN_HEIGHT);
                }
                context2d.restore();
            };
        }
        return Background;
    })(Sprite);
    GAME.Background = Background;
    /**
     * Splash class for splash screen
     */
    var Splash = (function (_super) {
        __extends(Splash, _super);
        /**
         * Splash constructor
         * @param spriteInfo
         * @param x
         * @param y
         */
        function Splash(spriteInfo, x, y) {
            var _this = this;
            _super.call(this, spriteInfo, x, y);
            /**
             * Splash render function
             * @param context2d
             */
            this.render = function (context2d) {
                context2d.save();
                var image = GAME.Resources.instance.getImage(_this.spriteInfo.url);
                if (image) {
                    context2d.drawImage(image, 0, 0, _this.spriteInfo.width, _this.spriteInfo.height, _this.position.x - _this.spriteInfo.halfWidth, _this.position.y - _this.spriteInfo.halfHeight, _this.spriteInfo.width, _this.spriteInfo.height);
                }
                context2d.restore();
            };
        }
        return Splash;
    })(Sprite);
    GAME.Splash = Splash;
    /**
     * DebrisField class for asteroid debris belt
     */
    var DebrisField = (function (_super) {
        __extends(DebrisField, _super);
        /**
         * DebrisField constructor
         * @param spriteInfo
         * @param x
         * @param y
         */
        function DebrisField(spriteInfo, x, y) {
            var _this = this;
            _super.call(this, spriteInfo, x, y);
            /**
             * DebrisField render function
             * @param context2d
             */
            this.render = function (context2d) {
                var image = GAME.Resources.instance.getImage(_this.spriteInfo.url), repeat = 2, xOffset = _this.position.x;
                if (image) {
                    while (repeat > 0) {
                        context2d.save();
                        context2d.translate(xOffset, _this.position.y);
                        context2d.drawImage(image, 0, 0, _this.spriteInfo.width, _this.spriteInfo.height, 0, 0, GAME.SCREEN_WIDTH, GAME.SCREEN_HEIGHT);
                        context2d.restore();
                        xOffset -= GAME.SCREEN_WIDTH;
                        repeat -= 1;
                    }
                }
            };
            /**
             * DebrisField update function
             */
            this.update = function () {
                _this.position.x += 1;
                if (_this.position.x >= GAME.SCREEN_WIDTH) {
                    _this.position.x -= GAME.SCREEN_WIDTH;
                }
            };
        }
        return DebrisField;
    })(Sprite);
    GAME.DebrisField = DebrisField;
    /**
     * SimulationObject class used for objects that utilize basic physics
     */
    var SimulationObject = (function (_super) {
        __extends(SimulationObject, _super);
        /**
         * SimulationObject constructor
         * @param spriteInfo
         * @param x
         * @param y
         */
        function SimulationObject(spriteInfo, x, y) {
            var _this = this;
            _super.call(this, spriteInfo, x, y);
            /**
             * wrap function used to make sure objects stay on screen
             */
            this.wrap = function () {
                if (_this.position.x < 0) {
                    _this.position.x = GAME.SCREEN_WIDTH - _this.position.x;
                }
                else if (_this.position.x > GAME.SCREEN_WIDTH) {
                    _this.position.x = _this.position.x - GAME.SCREEN_WIDTH;
                }
                if (_this.position.y < 0) {
                    _this.position.y = GAME.SCREEN_HEIGHT - _this.position.y;
                }
                else if (_this.position.y > GAME.SCREEN_HEIGHT) {
                    _this.position.y = _this.position.y - GAME.SCREEN_HEIGHT;
                }
            };
            /**
             * SimulationObject render function
             * @param context2d
             */
            this.render = function (context2d) {
                if (!_this.visible) {
                    return;
                }
                context2d.save();
                context2d.translate(_this.position.x, _this.position.y);
                context2d.rotate(_this.angle);
                var image = GAME.Resources.instance.getImage(_this.spriteInfo.url);
                if (image) {
                    context2d.drawImage(image, 0, 0, _this.spriteInfo.width, _this.spriteInfo.height, -_this.spriteInfo.halfWidth, -_this.spriteInfo.halfHeight, _this.spriteInfo.width, _this.spriteInfo.height);
                }
                context2d.restore();
            };
            /**
             * update function to move objects
             * NOTE: There are preUpdate and postUpdate function calls that can be overridden
             * in a subclass to do processing before and after (Template Pattern)
             */
            this.update = function () {
                _this.preUpdate();
                if (!_this.active) {
                    return;
                }
                _this.angle += _this.angularVelocity;
                _this.position.x += _this.velocity.x;
                _this.position.y += _this.velocity.y;
                _this.wrap();
                _this.postUpdate();
            };
            /**
             * Called before position and angle have been updated
             * NOTE: Override this in a subclass if needed
             */
            this.preUpdate = function () {
                // no op
            };
            /**
             * Called after position and angle have been updated
             * NOTE: Override this in a subclass if needed
             */
            this.postUpdate = function () {
                // no op
            };
            this.velocity = new GAME.Vector2d(0, 0);
            this.angle = 0;
            this.angularVelocity = 0;
            this.radius = spriteInfo.radius;
        }
        return SimulationObject;
    })(Sprite);
    GAME.SimulationObject = SimulationObject;
    /**
     * Missile class
     */
    var Missile = (function (_super) {
        __extends(Missile, _super);
        /**
         * Missile class constructor
         * @param spriteInfo
         * @param x
         * @param y
         */
        function Missile(spriteInfo, x, y) {
            var _this = this;
            _super.call(this, spriteInfo, x, y);
            /**
             * Overridden function that processes how many ticks until it deactivates
             */
            this.preUpdate = function () {
                _this.ticksToLive -= 1;
                if (_this.ticksToLive <= 0) {
                    _this.active = false;
                    _this.visible = false;
                    return;
                }
            };
            this.ticksToLive = 60;
        }
        return Missile;
    })(SimulationObject);
    GAME.Missile = Missile;
    /**
     * Asteroid class
     */
    var Asteroid = (function (_super) {
        __extends(Asteroid, _super);
        /**
         * Asteroid class constructor
         * @param spriteInfo
         * @param animationInfo
         * @param x
         * @param y
         * @param damage
         * @param points
         */
        function Asteroid(spriteInfo, animationInfo, x, y, damage, points) {
            var _this = this;
            _super.call(this, spriteInfo, x, y);
            /**
             * Asteroid render function
             * @param context2d
             */
            this.render = function (context2d) {
                var image = GAME.Resources.instance.getImage(_this.spriteInfo.url), xOffset, yOffset;
                if (!_this.visible) {
                    return;
                }
                if (_this.frame === _this.animationInfo.numberOfFrames) {
                    _this.frame = 0;
                }
                _this.tickCount += 1;
                if (_this.tickCount % _this.animationInfo.animationSpeed === 0) {
                    _this.frame += 1;
                }
                xOffset = (_this.frame % 9) * _this.spriteInfo.width;
                yOffset = 0;
                context2d.save();
                context2d.translate(_this.position.x, _this.position.y);
                if (image) {
                    context2d.drawImage(image, xOffset, yOffset, _this.spriteInfo.width, _this.spriteInfo.height, -_this.spriteInfo.halfWidth, -_this.spriteInfo.halfHeight, _this.spriteInfo.width, _this.spriteInfo.height);
                }
                context2d.restore();
            };
            this.animationInfo = animationInfo;
            this.frame = 0;
            this.tickCount = -1;
            this.finished = false;
            this.damage = damage;
            this.points = points;
        }
        return Asteroid;
    })(SimulationObject);
    GAME.Asteroid = Asteroid;
    /**
     * Ship class that represents the player in the game
     */
    var Ship = (function (_super) {
        __extends(Ship, _super);
        /**
         * Ship class constructor
         * @param spriteInfo
         * @param x
         * @param y
         */
        function Ship(spriteInfo, x, y) {
            var _this = this;
            _super.call(this, spriteInfo, x, y);
            /**
             * Ship render function
             * @param context2d
             */
            this.render = function (context2d) {
                var image = GAME.Resources.instance.getImage(_this.spriteInfo.url);
                context2d.save();
                context2d.translate(_this.position.x, _this.position.y);
                context2d.rotate(_this.angle);
                if (image) {
                    context2d.drawImage(image, 
                    // if thrusting, use the 2nd frame in the ship image
                    (_this.thrusting ? _this.spriteInfo.width : 0), 0, _this.spriteInfo.width, _this.spriteInfo.height, -_this.spriteInfo.halfWidth, -_this.spriteInfo.halfHeight, _this.spriteInfo.width, _this.spriteInfo.height);
                }
                context2d.restore();
            };
            /**
             * Adjusts velocity and acceleration
             */
            this.postUpdate = function () {
                var acceleration;
                /**
                 * Calculate velocity when thrusting using an acceleration clamp to limit
                 * maximum velocity
                 */
                if (_this.thrusting) {
                    acceleration = GAME.Vector2d.angleToVector2d(_this.angle);
                    _this.velocity.x += acceleration.x * _this.accelerationClamp;
                    _this.velocity.y += acceleration.y * _this.accelerationClamp;
                }
                /**
                 * Apply friction (not realistic in space!) so the ship will slowly come
                 * to a stop when not thrusting
                 */
                _this.velocity.x *= _this.friction;
                _this.velocity.y *= _this.friction;
            };
            this.accelerationClamp = 0.3; // acceleration limiter
            this.friction = 0.95; // friction used to slow ship down
            this.thrusting = false;
            this.maxShields = 100;
            this._shields = this.maxShields;
            this.score = 0;
            this.angle = Math.PI * (3 / 2);
        }
        Object.defineProperty(Ship.prototype, "shields", {
            /**
             * Gets the number of hit points remaining in the shield
             * @returns {number}
             */
            get: function () {
                return this._shields;
            },
            /**
             * Sets the number of hit points for the shield
             * @param value
             */
            set: function (value) {
                this._shields = value;
                if (this._shields < 0) {
                    this._shields = 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Retrieves the percentage left for the shield
         * @returns {number}
         */
        Ship.prototype.getShieldPercentage = function () {
            return this.shields / this.maxShields;
        };
        return Ship;
    })(SimulationObject);
    GAME.Ship = Ship;
    /**
     * SpriteMaker class is used as a sprite factory (Factory Pattern)
     * All sprites in the game are generated through this class
     */
    var SpriteMaker = (function () {
        function SpriteMaker() {
        }
        SpriteMaker.getSprite = function (what, x, y) {
            switch (what) {
                case "asteroid-small":
                    return new Asteroid(GAME.SpriteConfigs.asteroidSmallSpriteInfo, GAME.SpriteConfigs.asteroidAnimationInfo, x, y, 2, 300);
                case "asteroid-medium":
                    return new Asteroid(GAME.SpriteConfigs.asteroidMediumSpriteInfo, GAME.SpriteConfigs.asteroidAnimationInfo, x, y, 4, 200);
                case "asteroid-large":
                    return new Asteroid(GAME.SpriteConfigs.asteroidLargeSpriteInfo, GAME.SpriteConfigs.asteroidAnimationInfo, x, y, 6, 100);
                case "missile":
                    return new Missile(GAME.SpriteConfigs.missileSpriteInfo, x, y);
                case "ship":
                    return new Ship(GAME.SpriteConfigs.shipSpriteInfo, x, y);
                case "explosion":
                    return new Effect(GAME.SpriteConfigs.explosionSpriteInfo, GAME.SpriteConfigs.explosionAnimationInfo, x, y);
                case "shield-damage":
                    return new Effect(GAME.SpriteConfigs.shieldDamageSpriteInfo, GAME.SpriteConfigs.shieldDamageAnimationInfo, x, y);
                case "background":
                    return new Background(GAME.SpriteConfigs.backgroundSpriteInfo, x, y);
                case "debris-field":
                    return new DebrisField(GAME.SpriteConfigs.debrisFieldSpriteInfo, x, y);
                case "splash":
                    return new Splash(GAME.SpriteConfigs.splashSpriteInfo, x, y);
                default:
                    throw {
                        error: "Invalid Sprite Type",
                        message: "No such sprite type exists"
                    };
            }
        };
        return SpriteMaker;
    })();
    GAME.SpriteMaker = SpriteMaker;
})(GAME || (GAME = {}));
//# sourceMappingURL=sprite-maker.js.map
/**
 * This is the Render object that is used to manage draw calls
 */
/// <reference path='includes.ts'/>
var GAME;
(function (GAME) {
    "use strict";
    /* This is a Singleton that represents the Renderer class. Only one instance
     * of Renderer can exist.
     */
    var Renderer = (function () {
        /**
         * Renderer constructor
         * NOTE: Do not call this directly. Use the instance property.
         */
        function Renderer() {
            var _this = this;
            /**
             * Render functions from sprites are pushed into an array to create a list of
             * render commands
             * @param renderFunc
             */
            this.pushRenderFunction = function (renderFunc) {
                _this.renderFunctionList.push(renderFunc);
            };
            /**
             * Runs through all the render calls that have been pushed to the list
             */
            this.render = function () {
                _this.context.clearRect(0, 0, _this.canvas.width, _this.canvas.height);
                _this.renderFunctionList.forEach(function (renderFunc) {
                    renderFunc(_this.context);
                });
            };
            this.renderFunctionList = [];
            this.context = null;
            this.canvas = null;
            if (Renderer._instance) {
                throw new Error(Renderer.ERROR_DO_NOT_CALL_CONSTRUCTOR);
            }
            Renderer._instance = this;
        }
        Object.defineProperty(Renderer, "instance", {
            /**
             * Retrieves the single instance of the Renderer
             * @returns {Renderer}
             */
            get: function () {
                if (Renderer._instance === null) {
                    Renderer._instance = new Renderer();
                }
                return Renderer._instance;
            },
            enumerable: true,
            configurable: true
        });
        Renderer.prototype.setContext = function (context) {
            this.context = context;
        };
        Renderer.prototype.setCanvas = function (canvas) {
            this.canvas = canvas;
        };
        Renderer.prototype.flush = function () {
            this.renderFunctionList = [];
        };
        Renderer.ERROR_DO_NOT_CALL_CONSTRUCTOR = "Error: Instantiation failed: Use Resources.instance instead of new.";
        Renderer._instance = null;
        return Renderer;
    })();
    GAME.Renderer = Renderer;
})(GAME || (GAME = {}));
//# sourceMappingURL=renderer.js.map
/**
 * This is a modified version of resource manager from Udacity
 */
/// <reference path='includes.ts'/>
var GAME;
(function (GAME) {
    "use strict";
    /* This is a Singleton that represents the Resources class. Only one instance
     * of Resources can exist.
     */
    var Resources = (function () {
        /**
         * Resources constructor
         * NOTE: This should not be called directly. Use the instance property.
         */
        function Resources() {
            var _this = this;
            /**
             * Retrieves an image based off of its URL
             * @param url
             * @returns {any}
             */
            this.getImage = function (url) {
                return _this.resourceCache[url];
            };
            /**
             * Checks to see if a resource has been loaded
             * @returns {boolean}
             */
            this.isReady = function () {
                for (var k in _this.resourceCache) {
                    if (_this.resourceCache.hasOwnProperty(k) && !_this.resourceCache[k]) {
                        return false;
                    }
                }
                return true;
            };
            /**
             * When resources are loaded, the supplied function will be executed
             * @param func
             */
            this.onReady = function (func) {
                _this.readyCallbacks.push(func);
            };
            this.load = function (urlOrArr) {
                var that = _this;
                if (urlOrArr instanceof Array) {
                    /* If the developer passed in an array of images
                     * loop through each value and call our image
                     * loader on that image file
                     */
                    urlOrArr.forEach(function (url) {
                        that.loadInternally(url);
                    });
                }
                else {
                    /* The developer did not pass an array to this function,
                     * assume the value is a string and call our image loader
                     * directly.
                     */
                    _this.loadInternally(urlOrArr);
                }
            };
            this.loadInternally = function (url) {
                var that = _this;
                var image = null;
                if (_this.resourceCache[url]) {
                    /* If this URL has been previously loaded it will exist within
                     * our resourceCache array. Just return that image rather
                     * re-loading the image.
                     */
                    return _this.resourceCache[url];
                }
                else {
                    /* This URL has not been previously loaded and is not present
                     * within our cache; we'll need to load this image.
                     */
                    image = new Image();
                    image.onload = function () {
                        /* Once our image has properly loaded, add it to our cache
                         * so that we can simply return this image if the developer
                         * attempts to load this file in the future.
                         */
                        that.resourceCache[url] = image;
                        /* Once the image is actually loaded and properly cached,
                         * call all of the onReady() callbacks we have defined.
                         */
                        if (that.isReady()) {
                            that.readyCallbacks.forEach(function (func) {
                                func();
                            });
                        }
                    };
                    _this.resourceCache[url] = false;
                    image.src = url;
                }
            };
            if (Resources._instance) {
                throw new Error("Error: Instantiation failed: Use Resources.instance instead of new.");
            }
            this.resourceCache = {};
            this.readyCallbacks = [];
            Resources._instance = this;
        }
        Object.defineProperty(Resources, "instance", {
            /**
             * Returns the single instance of this class
             * @returns {Resources}
             */
            get: function () {
                if (Resources._instance === null) {
                    Resources._instance = new Resources();
                }
                return Resources._instance;
            },
            enumerable: true,
            configurable: true
        });
        Resources._instance = null;
        return Resources;
    })();
    GAME.Resources = Resources;
})(GAME || (GAME = {}));
//# sourceMappingURL=resources.js.map
/**
 * This a web adaptation of the Rice Rocks game that I created in
 * Coursera's Introduction to Interactive Python course.
 * It is an Asteroids(ish) clone :)
 */
/// <reference path='includes.ts' />
var GAME;
(function (GAME) {
    "use strict";
    /**
     * The game states that are valid in the game
     */
    var GameState;
    (function (GameState) {
        GameState[GameState["RUNNING"] = 0] = "RUNNING";
        GameState[GameState["SPLASH"] = 1] = "SPLASH";
    })(GameState || (GameState = {}));
    /**
     * Keyboard keys that are used in the game
     */
    var allowedKeys;
    (function (allowedKeys) {
        allowedKeys[allowedKeys["space"] = 32] = "space";
        allowedKeys[allowedKeys["left"] = 37] = "left";
        allowedKeys[allowedKeys["up"] = 38] = "up";
        allowedKeys[allowedKeys["right"] = 39] = "right";
        allowedKeys[allowedKeys["down"] = 40] = "down";
    })(allowedKeys || (allowedKeys = {}));
    /**
     * The screen dimensions used throughout the game
     */
    GAME.SCREEN_WIDTH = 800, GAME.SCREEN_HEIGHT = 800;
    /**
     * Returns a random integer between min (inclusive) and max (inclusive)
     * Using Math.round() will give you a non-uniform distribution!
     */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    /**
     * This is the game!
     */
    var RiceRocks = (function () {
        /**
         * RiceRocks constructor
         */
        function RiceRocks() {
            var _this = this;
            /**
             * Starts the game initially
             */
            this.init = function () {
                _this.reset();
            };
            /**
             * The main game loop that utilizes game states
             */
            this.main = function () {
                window.requestAnimationFrame(_this.main);
                switch (_this.gameState) {
                    case GameState.SPLASH:
                        _this.updateSplash(0);
                        _this.render();
                        break;
                    case GameState.RUNNING:
                        _this.update(0);
                        _this.collisionDetection();
                        _this.render();
                        _this.cleanup();
                        break;
                    default:
                        throw {
                            error: "Invalid Game State",
                            message: "Check the GameState enumeration for valid states"
                        };
                }
            };
            /**
             * Removes any unused effects, asteroids, and missiles and keeps
             * the ones that are still in play
             */
            this.cleanup = function () {
                var arrayLength, index, keepers;
                keepers = [];
                arrayLength = _this.effects.length;
                for (index = 0; index < arrayLength; index++) {
                    if (_this.effects[index].active) {
                        keepers.push(_this.effects[index]);
                    }
                }
                _this.effects = keepers;
                keepers = [];
                arrayLength = _this.asteroids.length;
                for (index = 0; index < arrayLength; index++) {
                    if (_this.asteroids[index].active) {
                        keepers.push(_this.asteroids[index]);
                    }
                }
                _this.asteroids = keepers;
                keepers = [];
                arrayLength = _this.missiles.length;
                for (index = 0; index < arrayLength; index++) {
                    if (_this.missiles[index].active) {
                        keepers.push(_this.missiles[index]);
                    }
                }
                _this.missiles = keepers;
            };
            /**
             * Used to update the render list for the splash screen during the GameState.SPLASH state
             */
            this.updateSplash = function () {
                // push the background to the render list first
                GAME.Renderer.instance.pushRenderFunction(_this.background.render);
                // update the scrolling debris field
                _this.debrisField.update();
                // push the debris field
                GAME.Renderer.instance.pushRenderFunction(_this.debrisField.render);
                // push the splash screen
                GAME.Renderer.instance.pushRenderFunction(_this.splash.render);
                // finally, push the UI (user interface)
                GAME.Renderer.instance.pushRenderFunction(_this.renderUI);
            };
            /**
             * Used to update game objects and the render list during the GameState.RUNNING state
             */
            this.update = function () {
                // push the background to the render list first
                GAME.Renderer.instance.pushRenderFunction(_this.background.render);
                // update the scrolling debris field
                _this.debrisField.update();
                // push the debris field
                GAME.Renderer.instance.pushRenderFunction(_this.debrisField.render);
                // update and push all the active missiles to the render list
                _this.missiles.forEach(function (missile) {
                    if (missile.active) {
                        missile.update();
                        GAME.Renderer.instance.pushRenderFunction(missile.render);
                    }
                });
                // update the player
                _this.player.update();
                // push the player to the render list
                GAME.Renderer.instance.pushRenderFunction(_this.player.render);
                // update and push all the active asteroids to the render list
                _this.asteroids.forEach(function (asteroid) {
                    if (asteroid.active) {
                        asteroid.update();
                        GAME.Renderer.instance.pushRenderFunction(asteroid.render);
                    }
                });
                // push all the active effects to the render list
                _this.effects.forEach(function (effect) {
                    if (effect.active) {
                        GAME.Renderer.instance.pushRenderFunction(effect.render);
                    }
                });
                // update the asteroid respawn tick counter
                _this.spawnTickCounter -= 1;
                if (_this.spawnTickCounter < 0) {
                    // if tick counter has expired, spawna  new asteroid
                    _this.spawnAsteroid();
                    // reset the spawn timer
                    _this.spawnTickCounter = RiceRocks.ASTEROID_RESPAWN_TIME;
                }
                // finally, push the UI (user interface) to the render list
                GAME.Renderer.instance.pushRenderFunction(_this.renderUI);
            };
            /**
             * The game's render function
             */
            this.render = function () {
                // execute all render calls pushed to the Renderer object
                GAME.Renderer.instance.render();
                // clear the renderer's draw list
                GAME.Renderer.instance.flush();
            };
            /**
             * Create a new asteroid!
             */
            this.spawnAsteroid = function () {
                var asteroid, randomChoice = getRandomInt(1, 3);
                // randomly create a large, medium, or small asteroid
                if (randomChoice === 1) {
                    asteroid = GAME.SpriteMaker.getSprite("asteroid-large", 0, 0);
                }
                else if (randomChoice === 2) {
                    asteroid = GAME.SpriteMaker.getSprite("asteroid-medium", 0, 0);
                }
                else {
                    asteroid = GAME.SpriteMaker.getSprite("asteroid-small", 0, 0);
                }
                // determine if the asteroid starts on the left or right side of the screen
                var positionX = getRandomInt(1, 2);
                // determine if the asteroid starts on the top or bottom side of the screen
                var positionY = getRandomInt(1, 2);
                positionX = positionX === 1 ? 0 : GAME.SCREEN_WIDTH;
                positionY = positionY === 1 ? 0 : GAME.SCREEN_HEIGHT;
                asteroid.position.x = positionX;
                asteroid.position.y = positionY;
                // randomly generate x and y velocities for the asteroid
                asteroid.velocity.x = getRandomInt(-300, 300) / 100;
                asteroid.velocity.y = getRandomInt(-300, 300) / 100;
                // randomly generate angular velocity
                asteroid.angularVelocity = getRandomInt(-10, 10) / 100;
                // mark it as in play
                asteroid.active = true;
                // put it in the asteroids list
                _this.asteroids.push(asteroid);
            };
            /**
             * Determine asteroid-player and asteroid-missile collisions
             */
            this.collisionDetection = function () {
                var missiles = _this.missiles, asteroidIndex, missileIndex, missile, asteroid, numAsteroids = _this.asteroids.length, numMissiles = missiles.length, player = _this.player;
                for (asteroidIndex = 0; asteroidIndex < numAsteroids; asteroidIndex++) {
                    asteroid = _this.asteroids[asteroidIndex];
                    // determine if an asteroid struck the player
                    if (player.active) {
                        if (asteroid.active && RiceRocks.collided(player, asteroid)) {
                            asteroid.active = false;
                            // hit was detected, create shield damage effect
                            _this.effects[_this.effects.length] =
                                GAME.SpriteMaker.getSprite("shield-damage", player.position.x, player.position.y);
                            // hit was detected, create an explosion effect
                            _this.effects[_this.effects.length] =
                                GAME.SpriteMaker.getSprite("explosion", asteroid.position.x, asteroid.position.y);
                            // play explosion sound
                            new Audio("audio/explosion.mp3").play();
                            // update player's remaining shields
                            _this.player.shields -= asteroid.damage;
                            // player still gets points for destroying an asteroid with his/her ship!
                            _this.player.score += asteroid.points;
                        }
                    }
                    // determine if an asteroid struck a missile
                    if (asteroid.active) {
                        for (missileIndex = 0; missileIndex < numMissiles; missileIndex++) {
                            missile = missiles[missileIndex];
                            if (missile.active && RiceRocks.collided(missile, asteroid)) {
                                missile.active = false;
                                asteroid.active = false;
                                // hit was detected, create an explosion effect
                                _this.effects[_this.effects.length] =
                                    GAME.SpriteMaker.getSprite("explosion", asteroid.position.x, asteroid.position.y);
                                // play explosion sound
                                new Audio("audio/explosion.mp3").play();
                                // give points to player
                                _this.player.score += asteroid.points;
                            }
                        }
                    }
                }
                // adjust high score if player has exceeded it
                if (_this.player.score > _this.highScore) {
                    _this.highScore = _this.player.score;
                }
                // end game if player has been eliminated
                if (_this.player.shields === 0) {
                    _this.gameState = GameState.SPLASH;
                    _this.reset();
                    return;
                }
            };
            /**
             * Processes the allowed keys and mouse input for the game
             * @param event
             */
            this.handleInput = function (event) {
                var eventType = event.type.toString();
                var keyCode = event.keyCode;
                if (eventType === "mousedown") {
                    if (_this.gameState === GameState.SPLASH) {
                        _this.gameState = GameState.RUNNING;
                    }
                }
                if (eventType === "keydown") {
                    switch (allowedKeys[keyCode]) {
                        case "left":
                            // turn left
                            _this.player.angularVelocity = -0.10;
                            break;
                        case "right":
                            // turn right
                            _this.player.angularVelocity = 0.10;
                            break;
                        case "up":
                            // toggle ship thrust
                            _this.player.thrusting = true;
                            break;
                        default:
                    }
                }
                if (eventType === "keyup") {
                    switch (allowedKeys[keyCode]) {
                        case "left":
                        case "right":
                            // stop turning
                            _this.player.angularVelocity = 0;
                            break;
                        case "up":
                            // stop ship thrust
                            _this.player.thrusting = false;
                            break;
                        case "space":
                            // shoot a missile
                            _this.shoot();
                            break;
                        default:
                    }
                }
            };
            /**
             * Render the simple UI for the game which includes:
             * shield gauge, score, and high score
             * @param context2d
             */
            this.renderUI = function (context2d) {
                var width = (GAME.SCREEN_WIDTH * 0.2), height = 20, x = (GAME.SCREEN_WIDTH / 2) - (width / 2), y = 20, lineWidth = 4, percentLeft = _this.player.getShieldPercentage();
                // draw the interior of the shield gauge
                context2d.save();
                context2d.fillStyle = _this.getShieldRGBA();
                context2d.fillRect(x + (width - (width * percentLeft)), y, width * percentLeft, height);
                context2d.restore();
                // draw the percentage remaining of the shield text
                context2d.save();
                context2d.font = "18px Arial";
                context2d.textAlign = "left";
                context2d.fillStyle = "white";
                context2d.fillText(Math.floor(percentLeft * 100).toString() + "%", x + (lineWidth), y + (lineWidth * 4));
                context2d.stroke();
                context2d.restore();
                // draw the border of the shield gauge
                context2d.save();
                context2d.lineWidth = lineWidth;
                context2d.strokeStyle = "rgba(255,255,255,0.75)";
                context2d.strokeRect(x, y, width, height);
                context2d.restore();
                // draw the score and high score text
                context2d.save();
                context2d.font = "20px Arial";
                context2d.fillStyle = "rgba(255,255,255,0.75)";
                context2d.fillText("Score: " + _this.player.score, 20, 37);
                context2d.fillText("Hi: " + _this.highScore, GAME.SCREEN_WIDTH - context2d.measureText("Hi: " + _this.highScore).width - 20, 37);
                context2d.restore();
            };
            GAME.Resources.instance.load(GAME.Assets.Images.art);
            this.asteroids = [];
            this.effects = [];
            this.missiles = [];
            this.background = GAME.SpriteMaker.getSprite("background", 0, 0);
            this.debrisField = GAME.SpriteMaker.getSprite("debris-field", 0, 0);
            // start player in the center of the screen
            this.player = GAME.SpriteMaker.getSprite("ship", GAME.SCREEN_WIDTH / 2, GAME.SCREEN_HEIGHT / 2);
            this.gameState = GameState.SPLASH;
            this.soundTrack = new Audio("audio/soundtrack.mp3");
            this.soundTrack.loop = true;
            this.highScore = 0;
            this.spawnTickCounter = RiceRocks.ASTEROID_RESPAWN_TIME;
            // center the splash screen
            this.splash = GAME.SpriteMaker.getSprite("splash", GAME.SCREEN_WIDTH / 2, GAME.SCREEN_HEIGHT / 2);
            // add event handlers
            document.addEventListener("keyup", this.handleInput);
            document.addEventListener("keydown", this.handleInput);
            document.addEventListener("mousedown", this.handleInput);
        }
        /**
         * Test to see whether or not 2 objects collided based on their radii
         * @param obj
         * @param otherObj
         * @returns {boolean}
         */
        RiceRocks.collided = function (obj, otherObj) {
            return GAME.Vector2d.distance(obj.position, otherObj.position) < obj.radius + otherObj.radius;
        };
        /**
         * Return the RGBA value that represents the player's shield condition
         * @returns {string}
         */
        RiceRocks.prototype.getShieldRGBA = function () {
            var r, g, b = 0, a = 0.75, rgba, percentLeft = this.player.getShieldPercentage();
            if (Math.floor(percentLeft * 100) > 50) {
                // when above 50% shield max, move from green to yellow
                r = (255 - Math.floor(percentLeft * 255)) * 2;
                g = 255;
            }
            else {
                // when below 50% shield max, move from yellow to red
                r = 255;
                g = Math.floor(percentLeft * 255) * 2;
            }
            rgba = [r, g, b, a];
            return "rgba(" + rgba.join(",") + ")";
        };
        /**
         * Make way for a new game!
         */
        RiceRocks.prototype.reset = function () {
            this.asteroids = [];
            this.effects = [];
            this.missiles = [];
            this.background = GAME.SpriteMaker.getSprite("background", 0, 0);
            this.player = GAME.SpriteMaker.getSprite("ship", GAME.SCREEN_WIDTH / 2, GAME.SCREEN_HEIGHT / 2);
            this.soundTrack.currentTime = 0;
        };
        /**
         * Fire a missile
         */
        RiceRocks.prototype.shoot = function () {
            var forwardVector2d, player = this.player, missile = GAME.SpriteMaker.getSprite("missile", 0, 0);
            // get the direction the ship is facing
            forwardVector2d = GAME.Vector2d.angleToVector2d(this.player.angle);
            // set missile's position based on player's orientation
            missile.position.set(player.position.x + player.radius * forwardVector2d.x, player.position.y + player.radius * forwardVector2d.y);
            // set missile's velocity based on player's orientation
            missile.velocity.set(player.velocity.x + 6 * forwardVector2d.x, player.velocity.y + 6 * forwardVector2d.y);
            // copy player's angle into missle's
            missile.angle = player.angle;
            // push the new missile into the missile list
            this.missiles.push(missile);
            // play missile sound
            new Audio("audio/missile.mp3").play();
        };
        RiceRocks.ASTEROID_RESPAWN_TIME = 15;
        return RiceRocks;
    })();
    GAME.RiceRocks = RiceRocks;
})(GAME || (GAME = {}));
/**
 * When the page is finished loading, begin the game
 */
window.onload = function () {
    var riceRocks = new GAME.RiceRocks(), doc = document, canvas = doc.createElement("canvas"), context2D = canvas.getContext("2d");
    canvas.width = GAME.SCREEN_WIDTH;
    canvas.height = GAME.SCREEN_HEIGHT;
    doc.body.appendChild(canvas);
    // prepare renderer
    GAME.Renderer.instance.setCanvas(canvas);
    GAME.Renderer.instance.setContext(context2D);
    // when resources are ready, execute init
    GAME.Resources.instance.onReady(riceRocks.init);
    // let the games begin!
    riceRocks.main();
};
//# sourceMappingURL=game.js.map